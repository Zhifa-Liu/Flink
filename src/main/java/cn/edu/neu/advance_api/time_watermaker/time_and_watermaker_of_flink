在 Flink 的流式处理中，会涉及到时间的不同概念，即：
a.事件时间(EventTime)：事件真真正正发生产生的时间
b.摄入时间(IngestionTime)：事件到达 Flink 的时间
c.处理时间(ProcessingTime)：事件真正被处理/计算的时间

上面的三个时间，我们更关注事件时间，只要事件时间一产生就不会变化！！！

Example>>>
一条错误日志的内容为：
2020-11:11 22:59:00 error NullPointException
故，事件时间为：2020-11:11 22:59:00
若进入 Flink 的时间为2020-11:11 23:00:00 --摄入时间
若到达 Window 的时间为2020-11:11 23:00:10 --处理时间

问题:
对于业务来说，要统计1h内的故障日志个数，哪个时间是最有意义的？
答案:
EventTime事件时间，因为bug真真正正产生的时间就是事件时间，只有事件时间才能真正反映/代表事件的本质!


    实际开发中我们希望基于事件时间来处理数据，但因为数据可能因为网络延迟等原因，出现了乱序
或延迟到达，那么可能处理的结果不是我们想要的甚至出现数据丢失的情况，所以需要一种机制来解决
一定程度上的数据乱序或延迟到达的问题！

>>> Watermaker 水印机制/水位线机制

1.什么是 Watermaker？
Watermaker 就是给数据再额外加的一个时间列，是一个时间戳!

2.如何计算 Watermaker？
Watermaker = 当前窗口的最大的事件时间  -  最大允许的延迟时间或乱序时间
# 只要不断有数据来，就可以保证 Watermaker 水位线一直上升(变大)，不会下降

3.Watermaker 有什么用？
    之前的窗口都是按照系统时间来触发计算的，如: [10:00:00 ~ 10:00:10) 的窗口，
一但系统时间到了10:00:10就会触发计算，那么可能会导致延迟到达的数据丢失!然而，
现在有了 Watermaker，窗口就可以按照 Watermaker 来触发计算!

4.Watermaker 是如何触发窗口计算的？
窗口计算的触发条件为:
(1). 窗口中有数据
(2). Watermaker >= 窗口的结束时间

当前窗口的最大的事件时间  >= 窗口的结束时间 +  最大允许的延迟时间或乱序时间
